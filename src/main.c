/*
** $Id: lua.c $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/

#define lua_c

#include "lprefix.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <signal.h>

#include "lua.h"

#include "lauxlib.h"
#include "lualib.h"

#include "lfs.h"

#include "argparse_lua.h"
#include "tl.h"
#include "tl_lua.h"

static const char *progname = "dora-tl";


/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}


/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/
static int pmain (lua_State *L) {
  int argc = (int)lua_tointeger(L, 1);
  char **argv = (char **)lua_touserdata(L, 2);
  luaL_openlibs(L);  /* open standard libraries */
  luaL_requiref(L, "lfs", luaopen_lfs, 0);
  /* create table 'arg' */
  lua_createtable(L, argc, 0);
  for (int i = 0; i < argc; i++) {
      lua_pushstring(L, argv[i]);
      lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);
  if (0 == luaL_loadbuffer(L, argparse_lua, sizeof(argparse_lua) / sizeof(argparse_lua[0]), "argparse")) {
      lua_call(L, 0, 1);
      lua_setfield(L, -2, "argparse");
  } else {
      luaL_error(L, "%s", lua_tostring(L, -1));
  }
  if (0 == luaL_loadbuffer(L, tl_lua, sizeof(tl_lua) / sizeof(tl_lua[0]), "tl")) {
      lua_call(L, 0, 1);
      lua_setfield(L, -2, "tl");
  } else {
      luaL_error(L, "%s", lua_tostring(L, -1));
  }
  lua_gc(L, LUA_GCGEN, 0, 0);  /* GC in generational mode */
  if (0 == luaL_loadbuffer(L, tl, sizeof(tl) / sizeof(tl[0]), "tl-cmd")) {
      lua_call(L, 0, 0);
  } else {
      luaL_error(L, "%s", lua_tostring(L, -1));
  }
  lua_pushboolean(L, 1);  /* signal no errors */
  return 1;
}


int main (int argc, char **argv) {
  int status, result;
  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return EXIT_FAILURE;
  }
  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}

